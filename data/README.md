## Dataset

The dataset for PaTS consists of solved planning problem instances from the chosen domain (e.g., Blocksworld).

### Generation Process

The dataset is generated using the `data/generate_dataset.sh` script. This script automates:

1.  **Problem Generation**: PDDL problem files (`.pddl`) are created.
2.  **Plan Generation**: Fast Downward finds a solution plan (`.plan`).
3.  **Plan Validation & State Extraction**: VAL validates the plan and its verbose output (`.val.log`) details state changes.
4.  **Parsing and Encoding**: `data/parse_and_encode.py` processes PDDL files and VAL logs to:
    - Reconstruct the state trajectory.
    - Encode each state into a binary vector.
    - Save trajectories (`.traj.bin.npy`), goals (`.goal.bin.npy`), and a **predicate manifest** (`predicate_manifest_<N>.txt`).
5.  **Dataset Splitting**: `data/analyze_dataset_splits.py` creates `train_files.txt`, `val_files.txt`, `test_files.txt`.

### Data Structure and Format

All generated data for `N` blocks is organized within `data/blocks_<N>/`. Key files per problem instance `blocks_<N>_problem_<M>`:

- `pddl/blocks_<N>_problem_<M>.pddl`: PDDL problem.
- `plans/blocks_<N>_problem_<M>.plan`: Expert plan.
- `val_out/blocks_<N>_problem_<M>.val.log`: VAL output.
- `trajectories_text/blocks_<N>_problem_<M>.traj.txt`: Human-readable trajectory.
- `trajectories_bin/blocks_<N>_problem_<M>.traj.bin.npy`: NumPy array `(L, F)` of binary states.
- `trajectories_bin/blocks_<N>_problem_<M>.goal.bin.npy`: NumPy array `(F,)` of the binary goal state.
- `predicate_manifest_<N>.txt`: **Crucial file** listing all possible ground predicates in their fixed order for `N` blocks. This defines the feature mapping for the binary vectors.
- `train_files.txt`, `val_files.txt`, `test_files.txt`: Lists of problem basenames for each split.

### State Encoding

- **Predicate Vocabulary & Manifest**: For a given `num_blocks`, `parse_and_encode.py` generates a `predicate_manifest_<N>.txt` file. This file contains an ordered list of all possible ground predicates (e.g., `(on-table b1)`, `(on b1 b2)`, `(clear b1)`, `(arm-empty)`, `(holding b1)`). This list defines the feature space and their exact order in the binary vector.
- **Binary Vector**: Each state (and the goal) is represented as a binary vector where each element corresponds to a predicate in the manifest. `1` means true, `0` means false.

### Predicate Manifest (`predicate_manifest_<N>.txt`)

This file is generated by `parse_and_encode.py` and stored in `data/blocks_<N>/`. It is essential for:

- **Consistent Encoding**: Ensuring all states for a given `num_blocks` use the same feature mapping.
- **Validator Configuration**: `BlocksWorldValidator.py` reads this manifest to understand the structure of the state vectors it needs to validate. This makes the validator robust to changes in predicate definitions or order, as long as the manifest is updated accordingly.
